<h1>Инкапсуляция и расширяемость типов</h1> 
<p><span>ООП – это сбалансированный подход к написанию программного обеспечения. Данные и поведение упакованы вместе. Такая инкапсуляция создает определяемые пользователем типы данных, расширяющие собственные типы данных языка и взаимодействующие с ними. Расширяемость типов – это возможность добавлять к языку определяемые пользователем типы данных,которые также легко использовать, как и <a href="/basis/types#base_types">основные&nbsp;типы</a>.</span></p>
<p><span>Абстрактный тип данных, например, строка, является описанием идеального, всем известного поведения типа. Пользователь строки знает, что операции, такие как конкатенация или печать, имеют определенное поведение. Операции конкатенации и печати называются методами. </span></p> 
<p><span>Конкретная реализация АТД может иметь ограничения; например, строки могут быть ограничены по длине. Эти ограничения влияют на открытое всем поведение. В то же время, внутренние или закрытые детали реализации не влияют прямо на то, как пользователь видит объект. Например, строка часто реализуется как массив; при этом внутренний базовый адрес элементов этого массива и его имя не существенны для пользователя.</span></p> 
<p><span>Инкапсуляция – это способность скрывать внутренние детали при предоставлении открытого интерфейса к определяемому пользователем типу. В MQL4, как и в C++, для обеспечения инкапсуляции используются определения класса и структуры (<a href="/basis/types/classes#class">class</a> и <a href="/basis/types/classes">struct</a>) в сочетании с ключевыми словами доступа </span><span style="color: #0000ff;">private</span><span> (закрытый), </span><span style="color: #0000ff;">protected</span><span> (защищенный) и </span><span style="color: #0000ff;">public</span><span> (открытый). </span></p>
<p><span>Ключевое слово </span><span style="color: #0000ff;">public</span><span> показывает, что доступ к членам, которые стоят за ним, является открытым безо всяких ограничений. Без этого ключевого слова члены класса по умолчанию закрыты. Закрытые члены доступны только функциям-членам только своего класса. </span></p> 
<p><span>Защищенные члены класса доступны функциям-членам не только своего класса, но и классов-наследников. Открытые члены доступны любой функции внутри области видимости объявления класса. Закрытость позволяет спрятать часть реализации класса, предотвращая тем самым непредвиденные изменения структуры данных. Ограничение доступа или сокрытие данных является особенностью объектно-ориентированного программирования.</span></p> 
<p><span>Обычно стараются защищать члены класса и объявлять их с модификатором protected, установку и чтение значений этих членов осуществляется с помощью специальныx так называемых set- и get-методов, которые определяются с модификатором доступа </span><span style="color: #0000ff;">public</span><span>.</span></p> 
<p><span style="font-weight: bold;">Пример:</span></p> 
<div style="text-align: left; text-indent: 0px; page-break-inside: avoid; border-color: #d8dfea; border-style: solid; border-width: thin; background: #fbf9f5; padding: 0px 0px 0px 0px; margin: 2px 17px 2px 17px;"> 
 <table cellpadding="3" style="border:none; border-spacing:0px;"> 
  <tbody> 
   <tr>
    <td style="vertical-align:top; padding:3px;"><p><span style="color: #0000ff;">class</span><span>&nbsp;CPerson</span><br> <span>&nbsp;&nbsp;{</span><br> <span style="color: #0000ff;">protected</span><span>:</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">string</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;имя</span><br> <span style="color: #0000ff;">public</span><span>:</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">void</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetName(</span><span style="color: #0000ff;">string</span><span>&nbsp;n){m_name=n;}</span><span style="color: #808080;">//&nbsp;устанавливает&nbsp;имя</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">string</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetName(){</span><span style="color: #0000ff;">return</span><span>&nbsp;(m_name);}&nbsp;</span><span style="color: #808080;">//&nbsp;возвращает&nbsp;имя</span><br> <span>&nbsp;&nbsp;};</span></p></td> 
   </tr> 
  </tbody> 
 </table> 
</div> 
<p><span>Такой подход дает несколько преимуществ. Во-первых, по имени функции можно понять что она делает – устанавливает или получает значение члена класса. Во-вторых, возможно в будущем нам понадобится изменить тип переменной m_name в самом классе CPerson или в каком-либо из производных от него классов. </span></p> 
<p><span>В таком случае нам достаточно будет изменить реализацию функций SetName() и GetName(), сами же объекты класса CPerson можно будет использовать в программе без каких-либо изменений в коде, так как пользователь не будет даже знать,что тип данных m_name изменился.</span></p> 
<p><span style="font-weight: bold;">Пример:</span></p> 
<div style="text-align: left; text-indent: 0px; page-break-inside: avoid; border-color: #d8dfea; border-style: solid; border-width: thin; background: #fbf9f5; padding: 0px 0px 0px 0px; margin: 2px 17px 2px 17px;"> 
 <table cellpadding="3" style="border:none; border-spacing:0px;"> 
  <tbody> 
   <tr>
    <td style="vertical-align:top; padding:3px;"><p><span style="color: #0000ff;">struct</span><span>&nbsp;Name</span><br> <span>&nbsp;&nbsp;{</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">string</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;имя</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">string</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;фамилия</span><br> <span>&nbsp;&nbsp;};</span><br> <span>&nbsp;</span><br> <span style="color: #0000ff;">class</span><span>&nbsp;CPerson</span><br> <span>&nbsp;&nbsp;{</span><br> <span style="color: #0000ff;">protected</span><span>:</span><br> <span>&nbsp;&nbsp;&nbsp;Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;имя</span><br> <span style="color: #0000ff;">public</span><span>:</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">void</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetName(</span><span style="color: #0000ff;">string</span><span>&nbsp;n);</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">string</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetName(){</span><span style="color: #0000ff;">return</span><span>(m_name.first_name+</span><span style="color: #008080;">"&nbsp;"</span><span>+m_name.last_name);}</span><br> <span style="color: #0000ff;">private</span><span>:</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">string</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetFirstName(</span><span style="color: #0000ff;">string</span><span>&nbsp;full_name);</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">string</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetLastName(</span><span style="color: #0000ff;">string</span><span>&nbsp;full_name);</span><br> <span>&nbsp;&nbsp;};</span><br> <span>&nbsp;</span><br> <span style="color: #0000ff;">void</span><span>&nbsp;CPerson::SetName(</span><span style="color: #0000ff;">string</span><span>&nbsp;n)</span><br> <span>&nbsp;&nbsp;{</span><br> <span>&nbsp;&nbsp;&nbsp;m_name.first_name=GetFirstName(n);</span><br> <span>&nbsp;&nbsp;&nbsp;m_name.last_name=GetLastName(n);</span><br> <span>&nbsp;&nbsp;}</span><br> <span>&nbsp;</span><br> <span style="color: #0000ff;">string</span><span>&nbsp;CPerson::GetFirstName(</span><span style="color: #0000ff;">string</span><span>&nbsp;full_name)</span><br> <span>&nbsp;&nbsp;{</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">int</span><span>&nbsp;pos=</span><span style="color: #0000ff;">StringFind</span><span>(full_name,</span><span style="color: #008080;">"&nbsp;"</span><span>);</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">if</span><span>(pos&gt;0)&nbsp;</span><span style="color: #0000ff;">StringSetCharacter</span><span>(full_name,pos,0);</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">return</span><span>(full_name);</span><br> <span>&nbsp;&nbsp;}</span><br> <span>&nbsp;</span><br> <span style="color: #0000ff;">string</span><span>&nbsp;CPerson::GetLastName(</span><span style="color: #0000ff;">string</span><span>&nbsp;full_name)</span><br> <span>&nbsp;&nbsp;{</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">string</span><span>&nbsp;ret_string;</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">int</span><span>&nbsp;pos=</span><span style="color: #0000ff;">StringFind</span><span>(full_name,</span><span style="color: #008080;">"&nbsp;"</span><span>);</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">if</span><span>(pos&gt;0)&nbsp;ret_string=</span><span style="color: #0000ff;">StringSubstr</span><span>(full_name,pos+1);</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">else</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret_string=full_name;</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">return</span><span>(ret_string);</span><br> <span>&nbsp;&nbsp;}</span></p></td> 
   </tr> 
  </tbody> 
 </table> 
</div> 
<p><span>Смотри также</span></p> 
<p><span><a href="/basis/types">Типы данных</a></span></p>
<br>