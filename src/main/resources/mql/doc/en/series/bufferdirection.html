<h1>Indexing Direction in Arrays, Buffers and Timeseries</h1> 
<p><span>The default indexing of all arrays and indicator buffers is left to right. The index of the first element is always equal to zero. Thus, the very first element of an array or indicator buffer with index 0 is by default on the extreme left position, while the last element is on the extreme right position.</span></p> 
<p><span>An indicator buffer is a <a href="/basis/types/dynamic_array">dynamic array</a> of type double, whose size is managed by the client terminals, so that it always corresponds to the number of bars the indicator is calculated on. A usual dynamic array of type double is assigned as an indicator buffer using the <a href="/customind/setindexbuffer">SetIndexBuffer()</a> function. Indicator buffers do not require setting of their size using function <a href="/array/arrayresize">ArrayResize()</a> - this will be done by the executing system of the terminal.</span></p> 
<p><span><a href="/series">Timeseries</a> are arrays with reverse indexing, i.e. the first element of a timeseries is in the extreme right position, and the last element is in the extreme left position. Timeseries being used for storing history price data and contain the time information, we can say that the newest data are placed in the extreme right position of the timeseries, while the oldest data are in the extreme left position. </span></p> 
<p><span>So the timeseries element with index 0 contains the information about the latest quote of a symbol. If a timeseries contains data on a daily timeframe, data of the current yet uncompleted day are located on the zero position, and the position with index 1 contains yesterday data.</span></p> 
<h3>Changing the Indexing Direction</h3> 
<p><span>Function <a href="/array/arraysetasseries">ArraySetAsSeries()</a> allows changing the method of accessing elements of a dynamic array; the physical order of data storing in the computer memory is not changed at that. This function simply changes the method of addressing array elements, so when copying one array to another using function <a href="/array/arraycopy">ArrayCopy()</a>, the contents of the recipient array will not depend on the indexing direction in the source array.</span></p> 
<p><span>Direction of indexing cannot be changed for statically distributed arrays. Even if an array was passed as a parameter to a function, attempts to change the indexing direction inside this function will bring no effect.</span></p> 
<p><span>For indicator buffers, like for usual arrays, indexing direction can also be set as backward (like in timeseries), i.e. reference to the zero position in the indicator buffer will mean reference to the last value on the corresponding indicator buffer and this will correspond to the value of the indicator on the latest bar. Still, the physical location of indicator bars will be unchanged.</span></p> 
<h3>Receiving Price Data in Indicators</h3> 
<p><span>Each <a href="/customind">custom indicator</a> must necessarily contain the <a href="/basis/function/events#oncalculate">OnCalculate()</a> function, to which price data required for calculating values in indicator buffers are passed. Indexing direction in these passed arrays can be found out using function <a href="/array/arraygetasseries">ArrayGetAsSeries()</a>.</span></p> 
<p><span>Arrays <a href="/basis/function/parameterpass">passed to the function</a> reflect price data, i.e. these arrays have the sign of a timeseries and function <a href="/array/arrayisseries">ArrayIsSeries()</a> will return true when checking these arrays. However, in any case indexing direction should be checked only by function <a href="/array/arraygetasseries">ArrayGetAsSeries()</a>. </span></p> 
<p><span>In order not to be dependent on default values, <a href="/array/arraysetasseries">ArraySetAsSeries()</a> should be unconditionally called for the arrays you are going to work with, and set the required direction.</span></p> 
<h3>Receiving Price Data and Indicator Values</h3> 
<p><span>Default indexing direction of all arrays in Expert Advisors, indicators and scripts is left-to-right. If necessary, in any mql4 program you can request timeseries values on any symbol and timeframe, as well as values of indicators calculated on any symbol and timeframe.</span></p> 
<p><span>Use functions Copy...() for these purposes:</span></p> 
<ul style="text-indent:0px; padding-left:0; margin-top:0; margin-bottom:0; margin-left: 30px;list-style-position:outside; list-style-type:disc"> 
 <li style="text-align: justify; padding: 0px 0px 0px 0px; margin-top: 3px; margin-right: 17px; margin-bottom: 3px;"><span><a href="/series/copyrates">CopyRates</a>  copy price history to an array of structures <a href="/constants/structures/mqlrates">MqlRates</a>;</span></li> 
 <li style="text-align: justify; padding: 0px 0px 0px 0px; margin-top: 3px; margin-right: 17px; margin-bottom: 3px;"><span><a href="/series/copytime">CopyTime</a>  copy Time values to an array of datetime type;</span></li> 
 <li style="text-align: justify; padding: 0px 0px 0px 0px; margin-top: 3px; margin-right: 17px; margin-bottom: 3px;"><span><a href="/series/copyopen">CopyOpen</a>  copy Open values to an array of double type;</span></li> 
 <li style="text-align: justify; padding: 0px 0px 0px 0px; margin-top: 3px; margin-right: 17px; margin-bottom: 3px;"><span><a href="/series/copyhigh">CopyHigh</a>  copy High values to an array of double type;</span></li> 
 <li style="text-align: justify; padding: 0px 0px 0px 0px; margin-top: 3px; margin-right: 17px; margin-bottom: 3px;"><span><a href="/series/copylow">CopyLow</a>  copy Low values to an array of double type;</span></li> 
 <li style="text-align: justify; padding: 0px 0px 0px 0px; margin-top: 3px; margin-right: 17px; margin-bottom: 3px;"><span><a href="/series/copyclose">CopyClose</a>  copy Close values to an array of double type;</span></li> 
 <li style="text-align: justify; padding: 0px 0px 0px 0px; margin-top: 3px; margin-right: 17px; margin-bottom: 3px;"><span><a href="/series/copytickvolume">CopyTickVolume</a>  copy tick volumes to an array of long type;</span></li> 
</ul> 
<p><span>&nbsp;</span></p> 
<p><span>All these functions work in a similar way. Let's consider the data obtaining mechanism on the example of CopyOpen(). It is implied that the indexing direction of requested data is that of timeseries, and the position with index 0 (zero) stores data of the current yet uncompleted bar. In order to get access to &nbsp;these data we need to copy the necessary volume of data into the recipient array, e.g. into array </span><span style="font-style: italic;">buffer</span><span>. </span></p> 
<p><img alt="CopyOpen" width="656" height="214" style="margin:0;width:656px;height:214px;border:none" src="https://c.mql4.com/i/docs/en/copyopen.png"></p> 
<p><span>When copying we need to specify the starting position in the source array, starting from which data will be copied to the recipient array. In case of success, the specified number of elements will be copied to the recipient array from the source array (from the indicator buffer in this case). Irrespective of the indexing value set in the recipient array, copying is always performed as is shown in the above figure.</span></p> 
<p><span>See also</span></p> 
<p><span><a href="/series/timeseries_access">Organizing Data Access</a></span></p> 
<br>