<h1>Polymorphism</h1> 
<p><span>Polymorphism is an opportunity for different classes of objects, related through inheritance, to respond in various ways when calling the same function element. It helps to create a universal mechanism describing the behavior of not only the base class, but also descendant classes.</span></p> 
<p><span>Let's continue to develop a base class CShape, and define a member function GetArea(), designed to calculate the area of a shape. In all the descendant classes, produced by inheritance from the base class, we redefine this function in accordance with rules of calculating the area of a particular shape.</span></p> 
<p><span>For a square (class CSquare), the area is calculated through its sides, for a circle (class CCircle), area is expressed through its radius etc. We can create an array to store objects of CShape type, in which both objects of a base class and those of all descendant classes can be stored. Further we can call the same function for each element of the array.</span></p> 
<p><span style="font-weight: bold;">Example:</span></p> 
<div style="text-align: left; text-indent: 0px; line-height: 1.0; page-break-inside: avoid; border-color: #b3b3b3; border-style: solid; border-width: thin; background: #fbf9f5; padding: 0px 0px 0px 0px; margin: 2px 17px 2px 17px;">
 <table cellpadding="3" style="border:none; border-spacing:0px;"> 
  <tbody>
   <tr>
    <td style="vertical-align:top; padding:3px;"><p><span style="color: #808080;">//---&nbsp;Base&nbsp;class</span><br> <span style="color: #0000ff;">class</span><span>&nbsp;CShape</span><br> <span>&nbsp;&nbsp;{</span><br> <span style="color: #0000ff;">protected</span><span>:&nbsp;</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">int</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;Shape&nbsp;type</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">int</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_xpos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;X&nbsp;-&nbsp;coordinate&nbsp;of&nbsp;the&nbsp;base&nbsp;point</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">int</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_ypos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;Y&nbsp;-&nbsp;coordinate&nbsp;of&nbsp;the&nbsp;base&nbsp;point</span><br> <span style="color: #0000ff;">public</span><span>:</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">void</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CShape(){m_type=</span><span style="color: #008080;">0</span><span>;};&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;constructor,&nbsp;type=0</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">int</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetType(){</span><span style="color: #0000ff;">return</span><span>(m_type);};</span><span style="color: #808080;">//&nbsp;returns&nbsp;type&nbsp;of&nbsp;the&nbsp;shape</span><br> <span style="color: #0000ff;">virtual</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">double</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GetArea(){</span><span style="color: #0000ff;">return</span><span>&nbsp;(</span><span style="color: #008080;">0</span><span>);&nbsp;}</span><span style="color: #808080;">//&nbsp;returns&nbsp;area&nbsp;of&nbsp;the&nbsp;shape</span><br> <span>&nbsp;&nbsp;};</span></p></td> 
   </tr> 
  </tbody>
 </table> 
</div> 
<p><span>Now, all of the derived classes have a member function getArea(), which returns a zero value. The implementation of this function in each descendant will vary.</span></p> 
<div style="text-align: left; text-indent: 0px; line-height: 1.0; page-break-inside: avoid; border-color: #b3b3b3; border-style: solid; border-width: thin; background: #fbf9f5; padding: 0px 0px 0px 0px; margin: 2px 17px 2px 17px;">
 <table cellpadding="3" style="border:none; border-spacing:0px;"> 
  <tbody>
   <tr>
    <td style="vertical-align:top; padding:3px;"><p><span style="color: #808080;">//---&nbsp;The&nbsp;derived&nbsp;class&nbsp;Circle</span><br> <span style="color: #0000ff;">class</span><span>&nbsp;CCircle&nbsp;:&nbsp;</span><span style="color: #0000ff;">public</span><span>&nbsp;CShape&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;After&nbsp;a&nbsp;colon&nbsp;we&nbsp;define&nbsp;the&nbsp;base&nbsp;class</span><br> <span>&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;from&nbsp;which&nbsp;inheritance&nbsp;is&nbsp;made</span><br> <span style="color: #0000ff;">private</span><span>:</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">double</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_radius;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;circle&nbsp;radius</span><br> <span>&nbsp;</span><br> <span style="color: #0000ff;">public</span><span>:</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">void</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCircle(){m_type=</span><span style="color: #008080;">1</span><span>;};&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;constructor,&nbsp;type=1&nbsp;</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">void</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetRadius(</span><span style="color: #0000ff;">double</span><span>&nbsp;r){m_radius=r;};</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">virtual</span><span>&nbsp;</span><span style="color: #0000ff;">double</span><span>&nbsp;GetArea(){</span><span style="color: #0000ff;">return</span><span>&nbsp;(</span><span style="color: #008080;">3</span><span>.</span><span style="color: #008080;">14</span><span>*m_radius*m_radius);}</span><span style="color: #808080;">//&nbsp;circle&nbsp;area</span><br> <span>&nbsp;&nbsp;};</span></p></td> 
   </tr> 
  </tbody>
 </table> 
</div> 
<p><span>For the class Square the declaration is the same:</span></p> 
<div style="text-align: left; text-indent: 0px; line-height: 1.0; page-break-inside: avoid; border-color: #b3b3b3; border-style: solid; border-width: thin; background: #fbf9f5; padding: 0px 0px 0px 0px; margin: 2px 17px 2px 17px;">
 <table cellpadding="3" style="border:none; border-spacing:0px;"> 
  <tbody>
   <tr>
    <td style="vertical-align:top; padding:3px;"><p><span style="color: #808080;">//---&nbsp;The&nbsp;derived&nbsp;class&nbsp;Square</span><br> <span style="color: #0000ff;">class</span><span>&nbsp;CSquare&nbsp;:&nbsp;</span><span style="color: #0000ff;">public</span><span>&nbsp;CShape&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;After&nbsp;a&nbsp;colon&nbsp;we&nbsp;define&nbsp;the&nbsp;base&nbsp;class</span><br> <span>&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;from&nbsp;which&nbsp;inheritance&nbsp;is&nbsp;made</span><br> <span style="color: #0000ff;">private</span><span>:</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">double&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_square_side;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;square&nbsp;side</span><br> <span>&nbsp;</span><br> <span style="color: #0000ff;">public</span><span>:</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">void</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSquare(){m_type=</span><span style="color: #008080;">2</span><span>;};&nbsp;</span><span style="color: #808080;">//&nbsp;constructor,&nbsp;type=1</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">void</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetSide(</span><span style="color: #0000ff;">double</span><span>&nbsp;s){m_square_side=s;};</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">virtual</span><span>&nbsp;</span><span style="color: #0000ff;">double&nbsp;</span><span>&nbsp;GetArea(){</span><span style="color: #0000ff;">return</span><span>&nbsp;(m_square_side*m_square_side);}</span><span style="color: #808080;">//&nbsp;square&nbsp;area</span><br> <span>&nbsp;&nbsp;};</span></p></td> 
   </tr> 
  </tbody>
 </table> 
</div> 
<p><span>For calculating the area of the square and circle, we need the corresponding values of m_radius and m_square_side, so we have added the functions SetRadius() and SetSide() in the declaration of the corresponding class.</span></p> 
<p><span>It is assumed that object of different types (CCircle and CSquare) derived from one base type CShape are used in our program. Polymorphism allows creating an array of objects of the base CShape class, but when declaring this array, these objects are yet unknown and their type is undefined. </span></p> 
<p><span>The decision on what type of object will be contained in each element of the array will be taken directly during program execution. This involves the <a href="/basis/operators/newoperator">dynamic creation</a> of objects of the appropriate classes, and hence the necessity to use <a href="/basis/types/object_pointers">object pointers</a> instead of objects. </span></p> 
<p><span>The <a href="/basis/operators/newoperator">new</a> operator is used for dynamic creation of objects. Each such object must be individually and explicitly deleted using the <a href="/basis/operators/deleteoperator">delete</a> operator. Therefore we will declare an array of pointers of CShape type, and create an object of a proper type for each element (</span><span style="font-weight: bold;">new Class_Name)</span><span>, as shown in the following script example:</span></p> 
<div style="text-align: left; text-indent: 0px; line-height: 1.0; page-break-inside: avoid; border-color: #b3b3b3; border-style: solid; border-width: thin; background: #fbf9f5; padding: 0px 0px 0px 0px; margin: 2px 17px 2px 17px;">
 <table cellpadding="3" style="border:none; border-spacing:0px;"> 
  <tbody>
   <tr>
    <td style="vertical-align:top; padding:3px;"><p><span style="color: #808080;">//+------------------------------------------------------------------+</span><br> <span style="color: #808080;">//|&nbsp;Script&nbsp;program&nbsp;start&nbsp;function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span><br> <span style="color: #808080;">//+------------------------------------------------------------------+</span><br> <span style="color: #0000ff;">void</span><span>&nbsp;</span><span style="color: #0000ff;">OnStart</span><span>()</span><br> <span>&nbsp;&nbsp;{</span><br> <span style="color: #808080;">//---&nbsp;Declare&nbsp;an&nbsp;array&nbsp;of&nbsp;object&nbsp;pointers&nbsp;of&nbsp;the&nbsp;base&nbsp;type&nbsp;</span><br> <span>&nbsp;&nbsp;&nbsp;CShape&nbsp;*shapes[5];&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//&nbsp;An&nbsp;array&nbsp;of&nbsp;pointers&nbsp;to&nbsp;CShape&nbsp;object</span><br> <span>&nbsp;</span><br> <span style="color: #808080;">//---&nbsp;Here&nbsp;fill&nbsp;in&nbsp;the&nbsp;array&nbsp;with&nbsp;derived&nbsp;objects</span><br> <span style="color: #808080;">//---&nbsp;Declare&nbsp;a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;object&nbsp;of&nbsp;CCircle&nbsp;type</span><br> <span>&nbsp;&nbsp;&nbsp;CCircle&nbsp;*circle=</span><span style="color: #0000ff;">new</span><span>&nbsp;CCircle();</span><br> <span style="color: #808080;">//---&nbsp;Set&nbsp;object&nbsp;properties&nbsp;at&nbsp;the&nbsp;circle&nbsp;pointer</span><br> <span>&nbsp;&nbsp;&nbsp;circle.SetRadius(2.5);</span><br> <span style="color: #808080;">//---&nbsp;Place&nbsp;the&nbsp;pointer&nbsp;value&nbsp;in&nbsp;shapes[0]</span><br> <span>&nbsp;&nbsp;&nbsp;shapes[0]=circle;</span><br> <span>&nbsp;</span><br> <span style="color: #808080;">//---&nbsp;Create&nbsp;another&nbsp;CCircle&nbsp;object&nbsp;and&nbsp;write&nbsp;down&nbsp;its&nbsp;pointer&nbsp;in&nbsp;shapes[1]</span><br> <span>&nbsp;&nbsp;&nbsp;circle=</span><span style="color: #0000ff;">new</span><span>&nbsp;CCircle();</span><br> <span>&nbsp;&nbsp;&nbsp;shapes[1]=circle;</span><br> <span>&nbsp;&nbsp;&nbsp;circle.SetRadius(5);</span><br> <span>&nbsp;</span><br> <span style="color: #808080;">//---&nbsp;Here&nbsp;we&nbsp;intentionally&nbsp;"forget"&nbsp;to&nbsp;set&nbsp;a&nbsp;value&nbsp;for&nbsp;shapes[2]</span><br> <span style="color: #808080;">//circle=new&nbsp;CCircle();</span><br> <span style="color: #808080;">//circle.SetRadius(10);</span><br> <span style="color: #808080;">//shapes[2]=circle;</span><br> <span>&nbsp;</span><br> <span style="color: #808080;">//---&nbsp;Set&nbsp;NULL&nbsp;for&nbsp;the&nbsp;element&nbsp;that&nbsp;is&nbsp;not&nbsp;used</span><br> <span>&nbsp;&nbsp;&nbsp;shapes[2]=</span><span style="color: #0000ff;">NULL</span><span>;</span><br> <span>&nbsp;</span><br> <span style="color: #808080;">//---&nbsp;Create&nbsp;a&nbsp;CSquare&nbsp;object&nbsp;and&nbsp;write&nbsp;down&nbsp;its&nbsp;pointer&nbsp;to&nbsp;shapes[3]</span><br> <span>&nbsp;&nbsp;&nbsp;CSquare&nbsp;*square=</span><span style="color: #0000ff;">new</span><span>&nbsp;CSquare();</span><br> <span>&nbsp;&nbsp;&nbsp;square.SetSide(5);</span><br> <span>&nbsp;&nbsp;&nbsp;shapes[3]=square;</span><br> <span>&nbsp;</span><br> <span style="color: #808080;">//---&nbsp;Create&nbsp;a&nbsp;CSquare&nbsp;object&nbsp;and&nbsp;write&nbsp;down&nbsp;its&nbsp;pointer&nbsp;to&nbsp;shapes[4]</span><br> <span>&nbsp;&nbsp;&nbsp;square=</span><span style="color: #0000ff;">new</span><span>&nbsp;CSquare();</span><br> <span>&nbsp;&nbsp;&nbsp;square.SetSide(10);</span><br> <span>&nbsp;&nbsp;&nbsp;shapes[4]=square;</span><br> <span>&nbsp;</span><br> <span style="color: #808080;">//---&nbsp;We&nbsp;have&nbsp;an&nbsp;array&nbsp;of&nbsp;pointers,&nbsp;get&nbsp;its&nbsp;size</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">int</span><span>&nbsp;total=</span><span style="color: #0000ff;">ArraySize</span><span>(shapes);</span><br> <span style="color: #808080;">//---&nbsp;Pass&nbsp;in&nbsp;a&nbsp;loop&nbsp;through&nbsp;all&nbsp;pointers&nbsp;in&nbsp;the&nbsp;array&nbsp;</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">for</span><span>(</span><span style="color: #0000ff;">int</span><span>&nbsp;i=0;&nbsp;i&lt;5;i++)</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//---&nbsp;If&nbsp;the&nbsp;pointer&nbsp;at&nbsp;the&nbsp;specified&nbsp;index&nbsp;is&nbsp;valid</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">if</span><span>(</span><span style="color: #0000ff;">CheckPointer</span><span>(shapes[i])!=</span><span style="color: #0000ff;">POINTER_INVALID</span><span>)</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//---&nbsp;Log&nbsp;the&nbsp;type&nbsp;and&nbsp;square&nbsp;of&nbsp;the&nbsp;shape</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">PrintFormat</span><span>(</span><span style="color: #008080;">"The&nbsp;object&nbsp;of&nbsp;type&nbsp;%d&nbsp;has&nbsp;the&nbsp;square&nbsp;%G"</span><span>,</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shapes[i].GetType(),</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shapes[i].GetArea());</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//---&nbsp;If&nbsp;the&nbsp;pointer&nbsp;has&nbsp;type&nbsp;POINTER_INVALID</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">else</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//---&nbsp;Notify&nbsp;of&nbsp;an&nbsp;error</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">PrintFormat</span><span>(</span><span style="color: #008080;">"Object&nbsp;shapes[%d]&nbsp;has&nbsp;not&nbsp;been&nbsp;initialized!&nbsp;Its&nbsp;pointer&nbsp;is&nbsp;%s"</span><span>,</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i,</span><span style="color: #0000ff;">EnumToString</span><span>(</span><span style="color: #0000ff;">CheckPointer</span><span>(shapes[i])));</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><br> <span>&nbsp;</span><br> <span style="color: #808080;">//---&nbsp;We&nbsp;must&nbsp;delete&nbsp;all&nbsp;created&nbsp;dynamic&nbsp;objects</span><br> <span>&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">for</span><span>(</span><span style="color: #0000ff;">int</span><span>&nbsp;i=0;i&lt;total;i++)</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//---&nbsp;We&nbsp;can&nbsp;delete&nbsp;only&nbsp;the&nbsp;objects&nbsp;with&nbsp;pointers&nbsp;of&nbsp;POINTER_DYNAMIC&nbsp;type</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">if</span><span>(</span><span style="color: #0000ff;">CheckPointer</span><span>(shapes[i])==</span><span style="color: #0000ff;">POINTER_DYNAMIC</span><span>)</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//---&nbsp;Notify&nbsp;of&nbsp;deletion</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">PrintFormat</span><span>(</span><span style="color: #008080;">"Deleting&nbsp;shapes[%d]"</span><span>,i);</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #808080;">//---&nbsp;Delete&nbsp;an&nbsp;object&nbsp;by&nbsp;its&nbsp;pointer</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: #0000ff;">delete</span><span>&nbsp;shapes[i];</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><br> <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><br> <span>&nbsp;&nbsp;}</span></p></td> 
   </tr> 
  </tbody>
 </table> 
</div> 
<p><span>Please note that when deleting an object using the <a href="/basis/operators/deleteoperator">delete</a> operator, <a href="/constants/namedconstants/enum_pointer_type">the type of its pointer</a> must be checked. Only objects with the <a href="/constants/namedconstants/enum_pointer_type">POINTER_DYNAMIC</a> pointer can be deleted using delete. For pointers of other type, an error will be returned.</span></p> 
<p><span>But besides the redefining of functions during inheritance, polymorphism also includes the implementation of one and the same functions with different sets of parameters within a class. This means that the class may have several functions with the same name but with a different type and/or set of parameters. In this case, polymorphism is implemented through the <a href="/basis/function/functionoverload">function overload</a>.</span></p> 
<p><span>&nbsp;</span></p> 
<br>